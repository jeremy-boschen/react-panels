#!/usr/bin/env node
/**
 * Extracts code marked with @demo-code annotations from demo files
 * and generates a TypeScript file with exported code strings.
 *
 * Usage: node scripts/extract-demo-code.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEMO_DIR = path.join(__dirname, '../demo/src/examples');
const OUTPUT_FILE = path.join(__dirname, '../demo/src/generated/demoCode.ts');

/**
 * Extracts code blocks marked with @demo-code-start and @demo-code-end
 * Supports both // comments and JSX-style comments
 */
function extractCodeBlocks(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const blocks = [];

  const lines = content.split('\n');
  let currentBlock = null;
  let blockLines = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check for start marker (both // and {/* */} formats)
    const startMatch = line.match(/(?:\/\/|\{\s*\/\*)\s*@demo-code-start(?:\s+([a-zA-Z0-9_-]+))?/);
    if (startMatch) {
      currentBlock = startMatch[1] || 'default';
      blockLines = [];
      continue;
    }

    // Check for end marker (both // and {/* */} formats)
    if (line.match(/(?:\/\/|\{\s*\/\*)\s*@demo-code-end/)) {
      if (currentBlock) {
        blocks.push({
          name: currentBlock,
          code: blockLines.join('\n')
        });
        currentBlock = null;
        blockLines = [];
      }
      continue;
    }

    // Collect lines within a block
    if (currentBlock) {
      blockLines.push(line);
    }
  }

  return blocks;
}

/**
 * Process all demo files and extract code blocks
 */
function processDemoFiles() {
  const demoFiles = fs.readdirSync(DEMO_DIR).filter(f => f.endsWith('.tsx'));
  const allBlocks = {};

  for (const file of demoFiles) {
    const filePath = path.join(DEMO_DIR, file);
    const baseName = file.replace('.tsx', '');
    const blocks = extractCodeBlocks(filePath);

    if (blocks.length > 0) {
      // If only one block and it's named 'default', use the file's base name
      if (blocks.length === 1 && blocks[0].name === 'default') {
        allBlocks[baseName] = blocks[0].code;
      } else {
        // Multiple blocks or named blocks
        for (const block of blocks) {
          const key = block.name === 'default' ? baseName : `${baseName}-${block.name}`;
          allBlocks[key] = block.code;
        }
      }
    }
  }

  return allBlocks;
}

/**
 * Generate TypeScript file with exported code strings
 */
function generateOutputFile(blocks) {
  const entries = Object.entries(blocks);

  if (entries.length === 0) {
    console.warn('⚠️  No demo code blocks found');
    return;
  }

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate TypeScript content
  let output = '/**\n';
  output += ' * Auto-generated file containing extracted demo code.\n';
  output += ' * DO NOT EDIT MANUALLY - Generated by scripts/extract-demo-code.mjs\n';
  output += ' */\n\n';
  output += 'export const demoCode: Record<string, string> = {\n';

  for (const [key, code] of entries) {
    // Escape backticks and ${} in the code
    const escapedCode = code
      .replace(/\\/g, '\\\\')
      .replace(/`/g, '\\`')
      .replace(/\$\{/g, '\\${');

    output += `  '${key}': \`${escapedCode}\`,\n\n`;
  }

  output += '};\n';

  fs.writeFileSync(OUTPUT_FILE, output, 'utf-8');

  console.log(`✅ Extracted ${entries.length} code block(s) to ${path.relative(process.cwd(), OUTPUT_FILE)}`);
  entries.forEach(([key]) => console.log(`   - ${key}`));
}

// Main execution
try {
  const blocks = processDemoFiles();
  generateOutputFile(blocks);
} catch (error) {
  console.error('❌ Error extracting demo code:', error);
  process.exit(1);
}
